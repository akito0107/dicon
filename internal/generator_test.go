package internal

import (
	"bytes"
	"testing"
)

func TestGenerator_appendHeader(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package main

	import "log"
`))
	g := &Generator{}
	it := &InterfaceType{
		PackageName: "main",
	}
	g.appendHeader(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: %s, actual: %s", ex, act)
	}

}

func TestGenerator_appendStructDef(t *testing.T) {
	ex := pretty(t, []byte(`type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

`))

	g := &Generator{}
	it := &InterfaceType{
		Name: "DIContainer",
	}
	g.appendStructDefs(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: ---\n%s\n---, actual: ---\n%s\n---", ex, act)
	}
}

func TestGenerator_appendMethods(t *testing.T) {
	ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() SampleComponent {
	if i, ok := d.store["SampleComponent"]; ok {
		if instance, ok := i.(SampleComponent); ok {
			return instance
		}
		log.Fatal("cached instance is polluted")
	}
	dep0 := d.Dependency()
	instance := NewSampleComponent(dep0)
	d.store["SampleComponent"] = instance
	return instance
}
`))
	p1 := parameterType{
		Type: "Dependency",
	}
	p2 := parameterType{
		Type: "SampleComponent",
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []parameterType{p1},
		ReturnTypes:   []parameterType{p2},
		PackageName:   "test",
	}

	it := &InterfaceType{Funcs: []FuncType{f1}}
	g := &Generator{PackageName: "test"}
	g.appendMethod(&it.Funcs, it.Name)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: ---\n%s\n---, actual: ---\n%s\n---", ex, act)
	}
}

func TestGenerator_appendMethodsMultipleDependencies(t *testing.T) {
	ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() SampleComponent {
	if i, ok := d.store["SampleComponent"]; ok {
		if instance, ok := i.(SampleComponent); ok {
			return instance
		}
		log.Fatal("cached instance is polluted")
	}
	dep0 := d.Dependency1()
	dep1 := d.Dependency2()
	instance := NewSampleComponent(dep0, dep1)
	d.store["SampleComponent"] = instance
	return instance
}
`))
	p1 := parameterType{
		Type: "Dependency1",
	}
	p2 := parameterType{
		Type: "Dependency2",
	}
	r1 := parameterType{
		Type: "SampleComponent",
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []parameterType{p1, p2},
		ReturnTypes:   []parameterType{r1},
		PackageName:   "test",
	}

	it := &InterfaceType{Funcs: []FuncType{f1}}
	g := &Generator{PackageName: "test"}
	g.appendMethod(&it.Funcs, "")

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: ---\n%s\n---, actual: ---\n%s\n---", ex, act)
	}
}

func TestGenerate(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import "log"

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() SampleComponent {
		if i, ok := d.store["SampleComponent"]; ok {
			if instance, ok := i.(SampleComponent); ok {
				return instance
			}
			log.Fatal("cached instance is polluted")
		}
		dep0 := d.Dependency1()
		dep1 := d.Dependency2()
		instance := NewSampleComponent(dep0, dep1)
		d.store["SampleComponent"] = instance
		return instance
	}`))

	p1 := parameterType{
		Type: "Dependency1",
	}
	p2 := parameterType{
		Type: "Dependency2",
	}
	r1 := parameterType{
		Type: "SampleComponent",
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []parameterType{p1, p2},
		ReturnTypes:   []parameterType{r1},
		PackageName:   "test",
	}

	it := &InterfaceType{
		Name:        "DIContainer",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}
	g := &Generator{}

	g.Generate(it, &it.Funcs)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: ---\n%s\n---, actual: ---\n%s\n---", ex, act)
	}
}

func TestGenerateSubPackage(t *testing.T) {
	ex := fixImports(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import (
		"log"

		"github.com/akito0107/dicon/sample"
	)

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() sample.SampleComponent {
		if i, ok := d.store["SampleComponent"]; ok {
			if instance, ok := i.(sample.SampleComponent); ok {
				return instance
			}
			log.Fatal("cached instance is polluted")
		}
		dep0 := d.Dependency1()
		dep1 := d.Dependency2()
		instance := NewSampleComponent(dep0, dep1)
		d.store["SampleComponent"] = instance
		return instance
	}`))

	p1 := parameterType{
		Type: "Dependency1",
	}
	p2 := parameterType{
		Type: "Dependency2",
	}
	r1 := parameterType{
		Type: "SampleComponent",
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []parameterType{p1, p2},
		ReturnTypes:   []parameterType{r1},
		PackageName:   "sample",
	}

	it := &InterfaceType{
		Name:        "DIContainer",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}
	g := &Generator{}

	g.Generate(it, &it.Funcs)

	act := fixImports(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: ---\n%s\n---, actual: ---\n%s\n---", ex, act)
	}
}
