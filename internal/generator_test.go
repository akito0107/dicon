package internal

import (
	"bytes"
	"testing"

	"go/ast"
	"go/parser"

	"github.com/andreyvit/diff"
)

func TestGenerator_appendHeader(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package main

	import (
		"log"
		"github.com/pkg/errors"
	)
`))
	g := &Generator{PackageName: "main"}
	it := &InterfaceType{
		PackageName: "main",
	}
	g.appendHeader(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}

}

func TestGenerator_appendStructDef(t *testing.T) {
	ex := pretty(t, []byte(`type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

`))

	g := &Generator{}
	it := &InterfaceType{
		Name: "DIContainer",
	}
	g.appendStructDefs(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerator_appendMethods(t *testing.T) {
	ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() (SampleComponent, error) {
	if i, ok := d.store["SampleComponent"]; ok {
		instance, ok := i.(SampleComponent)
		if !ok {
			return nil, fmt.Errorf("invalid instance is cached %v", instance)
		}
		return instance, nil
	}
	dep0, err := d.Dependency()
	if err != nil {
		return nil, errors.Wrap(err, "resolve Dependency failed at DICON")
	}
	instance, err := NewSampleComponent(dep0)
	if err != nil {
		return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
	}
	d.store["SampleComponent"] = instance
	return instance, nil
}
`))
	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "SampleComponent"),
	}
	e1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "error"),
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1},
		ReturnTypes:   []ParameterType{p2, e1},
		PackageName:   "test",
	}

	it := &InterfaceType{Funcs: []FuncType{f1}}
	g := &Generator{PackageName: "test"}
	g.appendMethod(it.Funcs)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerator_appendMethodsMultipleDependencies(t *testing.T) {
	ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() (SampleComponent, error) {
	if i, ok := d.store["SampleComponent"]; ok {
		instance, ok := i.(SampleComponent)
		if !ok {
			return nil, fmt.Errorf("invalid instance is cached %v", instance)
		}
		return instance, nil
	}
	dep0, err := d.Dependency1()
	if err != nil {
		return nil, errors.Wrap(err, "resolve Dependency1 failed at DICON")
	}
	dep1, err := d.Dependency2()
	if err != nil {
		return nil, errors.Wrap(err, "resolve Dependency2 failed at DICON")
	}
	instance, err := NewSampleComponent(dep0, dep1)
	if err != nil {
		return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
	}
	d.store["SampleComponent"] = instance
	return instance, nil
}
`))
	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "SampleComponent"),
	}
	e1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "error"),
	}
	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, e1},
		PackageName:   "test",
	}

	it := &InterfaceType{Funcs: []FuncType{f1}}
	g := &Generator{PackageName: "test"}
	g.appendMethod(it.Funcs)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerate(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import (
		"log"
		"github.com/pkg/errors"
	)

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() (SampleComponent, error) {
		if i, ok := d.store["SampleComponent"]; ok {
			instance, ok := i.(SampleComponent)
			if !ok {
				return nil, fmt.Errorf("invalid instance is cached %v", instance)
			}
			return instance, nil
		}
		dep0, err := d.Dependency1()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency1 failed at DICON")
		}
		dep1, err := d.Dependency2()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency2 failed at DICON")
		}
		instance, err := NewSampleComponent(dep0, dep1)
		if err != nil {
			return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
		}
		d.store["SampleComponent"] = instance
		return instance, nil
	}`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "SampleComponent"),
	}
	e1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "error"),
	}
	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, e1},
		PackageName:   "test",
	}

	it := &InterfaceType{
		Name:        "DIContainer",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}
	g := &Generator{
		PackageName: "test",
	}

	g.Generate(it, it.Funcs)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerateSubPackage(t *testing.T) {
	ex := fixImports(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import (
		"log"

		"github.com/akito0107/dicon/sample"
		"github.com/pkg/errors"
	)

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() (sample.SampleComponent, error) {
		if i, ok := d.store["SampleComponent"]; ok {
			instance, ok := i.(sample.SampleComponent)
			if !ok {
				return nil, fmt.Errorf("invalid instance is cached %v", instance)
			}
			return instance, nil
		}
		dep0, err := d.Dependency1()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency1 failed at DICON")
		}
		dep1, err := d.Dependency2()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency2 failed at DICON")
		}
		instance, err := sample.NewSampleComponent(dep0, dep1)
		if err != nil {
			return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
		}
		d.store["SampleComponent"] = instance
		return instance, nil
	}`))

	p1 := ParameterType{
		DeclaredPackageName: "sample",
		src:                 createAst(t, "Dependency1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "sample",
		src:                 createAst(t, "Dependency2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "sample",
		src:                 createAst(t, "SampleComponent"),
	}
	e1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "error"),
	}
	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, e1},
		PackageName:   "sample",
	}

	it := &InterfaceType{
		Name:        "DIContainer",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}
	g := Generator{
		PackageName: "test",
	}
	g.Generate(it, it.Funcs)

	act := fixImports(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStruct(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFuncMock func(a0 Arg1, a1 Arg2) Ret1
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc(a0 Arg1, a1 Arg2) Ret1 {
		return mk.TestFuncMock(a0, a1)
	}
`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret1"),
	}

	f1 := FuncType{
		Name:          "TestFunc",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStructMultipleFuncs(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFunc1Mock func(a0 Arg1)
		TestFunc2Mock func(a0 Arg1, a1 Arg2) (Ret1, Ret2)
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc1(a0 Arg1) {
		mk.TestFunc1Mock(a0)
	}
	func (mk *TestInterfaceMock) TestFunc2(a0 Arg1, a1 Arg2) (Ret1, Ret2) {
		return mk.TestFunc2Mock(a0, a1)
	}
`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret1"),
	}
	r2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret2"),
	}

	f1 := FuncType{
		Name:          "TestFunc1",
		ArgumentTypes: []ParameterType{p1},
		ReturnTypes:   []ParameterType{},
	}

	f2 := FuncType{
		Name:          "TestFunc2",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, r2},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1, f2},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStructMultipleFuncWithPackages(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFunc1Mock func(a0 pak1.Arg1)
		TestFunc2Mock func(a0 pak1.Arg1, a1 Arg2) (Ret1, pak2.Ret2)
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc1(a0 pak1.Arg1) {
		mk.TestFunc1Mock(a0)
	}
	func (mk *TestInterfaceMock) TestFunc2(a0 pak1.Arg1, a1 Arg2) (Ret1, pak2.Ret2) {
		return mk.TestFunc2Mock(a0, a1)
	}
`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "pak1.Arg1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret1"),
	}
	r2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "pak2.Ret2"),
	}

	f1 := FuncType{
		Name:          "TestFunc1",
		ArgumentTypes: []ParameterType{p1},
		ReturnTypes:   []ParameterType{},
	}

	f2 := FuncType{
		Name:          "TestFunc2",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, r2},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1, f2},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStructVariadicArguments(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFunc1Mock func(a0 string, a1 ...interface{}) error
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc1(a0 string, a1 ...interface{}) error {
		return mk.TestFunc1Mock(a0, a1...)
	}
`))

	p1 := ParameterType{
		src: createAst(t, "string"),
	}
	p2 := ParameterType{
		src: &ast.Ellipsis{
			Elt: &ast.InterfaceType{},
		},
	}
	r1 := ParameterType{
		src: createAst(t, "error"),
	}

	f1 := FuncType{
		Name:          "TestFunc1",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func createAst(t *testing.T, expr string) ast.Expr {
	t.Helper()
	ex, err := parser.ParseExpr(expr)
	if err != nil {
		t.Fatal(ex)
		return nil
	}
	return ex
}
