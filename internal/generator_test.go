package internal

import (
	"bytes"
	"testing"

	"go/ast"
	"go/parser"

	"github.com/andreyvit/diff"
)

func TestGenerator_appendHeader(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package main

	import "log"
`))
	g := &Generator{PackageName: "main"}
	it := &InterfaceType{
		PackageName: "main",
	}
	g.appendHeader(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}

}

func TestGenerator_appendStructDef(t *testing.T) {
	ex := pretty(t, []byte(`type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

`))

	g := &Generator{}
	it := &InterfaceType{
		Name: "DIContainer",
	}
	g.appendStructDefs(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerator_appendMethods(t *testing.T) {
	ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() SampleComponent {
	if i, ok := d.store["SampleComponent"]; ok {
		if instance, ok := i.(SampleComponent); ok {
			return instance
		}
		log.Fatal("cached instance is polluted")
	}
	dep0 := d.Dependency()
	instance := NewSampleComponent(dep0)
	d.store["SampleComponent"] = instance
	return instance
}
`))
	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "SampleComponent"),
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1},
		ReturnTypes:   []ParameterType{p2},
		PackageName:   "test",
	}

	it := &InterfaceType{Funcs: []FuncType{f1}}
	g := &Generator{PackageName: "test"}
	g.appendMethod(it.Funcs, it.Name)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: ex: ---\n%s\n---, actual: ---\n%s\n---", ex, act)
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerator_appendMethodsMultipleDependencies(t *testing.T) {
	ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() SampleComponent {
	if i, ok := d.store["SampleComponent"]; ok {
		if instance, ok := i.(SampleComponent); ok {
			return instance
		}
		log.Fatal("cached instance is polluted")
	}
	dep0 := d.Dependency1()
	dep1 := d.Dependency2()
	instance := NewSampleComponent(dep0, dep1)
	d.store["SampleComponent"] = instance
	return instance
}
`))
	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "SampleComponent"),
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1},
		PackageName:   "test",
	}

	it := &InterfaceType{Funcs: []FuncType{f1}}
	g := &Generator{PackageName: "test"}
	g.appendMethod(it.Funcs, "")

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerate(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import "log"

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() SampleComponent {
		if i, ok := d.store["SampleComponent"]; ok {
			if instance, ok := i.(SampleComponent); ok {
				return instance
			}
			log.Fatal("cached instance is polluted")
		}
		dep0 := d.Dependency1()
		dep1 := d.Dependency2()
		instance := NewSampleComponent(dep0, dep1)
		d.store["SampleComponent"] = instance
		return instance
	}`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Dependency2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "SampleComponent"),
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1},
		PackageName:   "test",
	}

	it := &InterfaceType{
		Name:        "DIContainer",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}
	g := &Generator{
		PackageName: "test",
	}

	g.Generate(it, it.Funcs)

	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestGenerateSubPackage(t *testing.T) {
	ex := fixImports(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import (
		"log"

		"github.com/akito0107/dicon/sample"
	)

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() sample.SampleComponent {
		if i, ok := d.store["SampleComponent"]; ok {
			if instance, ok := i.(sample.SampleComponent); ok {
				return instance
			}
			log.Fatal("cached instance is polluted")
		}
		dep0 := d.Dependency1()
		dep1 := d.Dependency2()
		instance := sample.NewSampleComponent(dep0, dep1)
		d.store["SampleComponent"] = instance
		return instance
	}`))

	p1 := ParameterType{
		DeclaredPackageName: "sample",
		src:                 createAst(t, "Dependency1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "sample",
		src:                 createAst(t, "Dependency2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "sample",
		src:                 createAst(t, "SampleComponent"),
	}

	f1 := FuncType{
		Name:          "SampleComponent",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1},
		PackageName:   "sample",
	}

	it := &InterfaceType{
		Name:        "DIContainer",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}
	g := Generator{
		PackageName: "test",
	}
	g.Generate(it, it.Funcs)

	act := fixImports(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStruct(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFuncMock func(a0 Arg1, a1 Arg2) Ret1
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc(a0 Arg1, a1 Arg2) Ret1 {
		return mk.TestFuncMock(a0, a1)
	}
`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret1"),
	}

	f1 := FuncType{
		Name:          "TestFunc",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStructMultipleFuncs(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFunc1Mock func(a0 Arg1)
		TestFunc2Mock func(a0 Arg1, a1 Arg2) (Ret1, Ret2)
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc1(a0 Arg1) {
		return mk.TestFunc1Mock(a0)
	}
	func (mk *TestInterfaceMock) TestFunc2(a0 Arg1, a1 Arg2) (Ret1, Ret2) {
		return mk.TestFunc2Mock(a0, a1)
	}
`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret1"),
	}
	r2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret2"),
	}

	f1 := FuncType{
		Name:          "TestFunc1",
		ArgumentTypes: []ParameterType{p1},
		ReturnTypes:   []ParameterType{},
	}

	f2 := FuncType{
		Name:          "TestFunc2",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, r2},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1, f2},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestAppendMockStructMultipleFuncWithPackages(t *testing.T) {
	ex := pretty(t, []byte(`type TestInterfaceMock struct {
		TestFunc1Mock func(a0 pak1.Arg1)
		TestFunc2Mock func(a0 pak1.Arg1, a1 Arg2) (Ret1, pak2.Ret2)
	}

	func NewTestInterfaceMock() *TestInterfaceMock {
		return &TestInterfaceMock{}
	}

	func (mk *TestInterfaceMock) TestFunc1(a0 pak1.Arg1) {
		return mk.TestFunc1Mock(a0)
	}
	func (mk *TestInterfaceMock) TestFunc2(a0 pak1.Arg1, a1 Arg2) (Ret1, pak2.Ret2) {
		return mk.TestFunc2Mock(a0, a1)
	}
`))

	p1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "pak1.Arg1"),
	}
	p2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Arg2"),
	}
	r1 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "Ret1"),
	}
	r2 := ParameterType{
		DeclaredPackageName: "test",
		src:                 createAst(t, "pak2.Ret2"),
	}

	f1 := FuncType{
		Name:          "TestFunc1",
		ArgumentTypes: []ParameterType{p1},
		ReturnTypes:   []ParameterType{},
	}

	f2 := FuncType{
		Name:          "TestFunc2",
		ArgumentTypes: []ParameterType{p1, p2},
		ReturnTypes:   []ParameterType{r1, r2},
	}

	it := &InterfaceType{
		Name:        "TestInterface",
		PackageName: "test",
		Funcs:       []FuncType{f1, f2},
	}

	g := Generator{
		PackageName: "test",
	}
	g.appendMockStruct(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func createAst(t *testing.T, expr string) ast.Expr {
	ex, err := parser.ParseExpr(expr)
	if err != nil {
		t.Fatal(ex)
		return nil
	}
	return ex
}
