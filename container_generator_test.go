package dicon

import (
	"bytes"
	"testing"

	"github.com/andreyvit/diff"
)

func TestContainerGenerator_AppendHeader(t *testing.T) {
	ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package main

	import (
		"log"
		"github.com/pkg/errors"
	)
`))
	g := &ContainerGenerator{Generator: Generator{PackageName: "main"}}
	it := &InterfaceType{
		PackageName: "main",
	}
	g.AppendHeader(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestContainerGenerator_AppendStructDef(t *testing.T) {
	ex := pretty(t, []byte(`type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

`))

	g := &ContainerGenerator{}
	it := &InterfaceType{
		Name: "DIContainer",
	}
	g.AppendStructDefs(it)
	act := pretty(t, g.buf.Bytes())
	if !bytes.Equal(act, ex) {
		t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
	}
}

func TestContainerGenerator_AppendMethods(t *testing.T) {
	t.Run("Single Dependency", func(t *testing.T) {
		ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() (SampleComponent, error) {
	if i, ok := d.store["SampleComponent"]; ok {
		instance, ok := i.(SampleComponent)
		if !ok {
			return nil, fmt.Errorf("invalid instance is cached %v", instance)
		}
		return instance, nil
	}
	dep0, err := d.Dependency()
	if err != nil {
		return nil, errors.Wrap(err, "resolve Dependency failed at DICON")
	}
	instance, err := NewSampleComponent(dep0)
	if err != nil {
		return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
	}
	d.store["SampleComponent"] = instance
	return instance, nil
}
`))
		p1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "Dependency"),
		}
		p2 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "SampleComponent"),
		}
		e1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "error"),
		}

		f1 := FuncType{
			Name:          "SampleComponent",
			ArgumentTypes: []ParameterType{p1},
			ReturnTypes:   []ParameterType{p2, e1},
			PackageName:   "test",
		}

		it := &InterfaceType{Funcs: []FuncType{f1}}
		g := &ContainerGenerator{Generator: Generator{PackageName: "test"}}
		g.AppendMethod(it.Funcs, it.Name)

		act := pretty(t, g.buf.Bytes())
		if !bytes.Equal(act, ex) {
			t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
		}

	})
	t.Run("Multiple Dependencies", func(t *testing.T) {
		ex := pretty(t, []byte(`func (d *dicontainer) SampleComponent() (SampleComponent, error) {
	if i, ok := d.store["SampleComponent"]; ok {
		instance, ok := i.(SampleComponent)
		if !ok {
			return nil, fmt.Errorf("invalid instance is cached %v", instance)
		}
		return instance, nil
	}
	dep0, err := d.Dependency1()
	if err != nil {
		return nil, errors.Wrap(err, "resolve Dependency1 failed at DICON")
	}
	dep1, err := d.Dependency2()
	if err != nil {
		return nil, errors.Wrap(err, "resolve Dependency2 failed at DICON")
	}
	instance, err := NewSampleComponent(dep0, dep1)
	if err != nil {
		return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
	}
	d.store["SampleComponent"] = instance
	return instance, nil
}
`))
		p1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "Dependency1"),
		}
		p2 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "Dependency2"),
		}
		r1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "SampleComponent"),
		}
		e1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "error"),
		}
		f1 := FuncType{
			Name:          "SampleComponent",
			ArgumentTypes: []ParameterType{p1, p2},
			ReturnTypes:   []ParameterType{r1, e1},
			PackageName:   "test",
		}

		it := &InterfaceType{Funcs: []FuncType{f1}}
		g := &ContainerGenerator{Generator: Generator{PackageName: "test"}}
		g.AppendMethod(it.Funcs, "")

		act := pretty(t, g.buf.Bytes())
		if !bytes.Equal(act, ex) {
			t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
		}
	})
}

func TestContainerGenerator_Generate(t *testing.T) {
	t.Run("Simple case", func(t *testing.T) {

		ex := pretty(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import (
		"log"
		"github.com/pkg/errors"
	)

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() (SampleComponent, error) {
		if i, ok := d.store["SampleComponent"]; ok {
			instance, ok := i.(SampleComponent)
			if !ok {
				return nil, fmt.Errorf("invalid instance is cached %v", instance)
			}
			return instance, nil
		}
		dep0, err := d.Dependency1()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency1 failed at DICON")
		}
		dep1, err := d.Dependency2()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency2 failed at DICON")
		}
		instance, err := NewSampleComponent(dep0, dep1)
		if err != nil {
			return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
		}
		d.store["SampleComponent"] = instance
		return instance, nil
	}`))

		p1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "Dependency1"),
		}
		p2 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "Dependency2"),
		}
		r1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "SampleComponent"),
		}
		e1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "error"),
		}
		f1 := FuncType{
			Name:          "SampleComponent",
			ArgumentTypes: []ParameterType{p1, p2},
			ReturnTypes:   []ParameterType{r1, e1},
			PackageName:   "test",
		}

		it := &InterfaceType{
			Name:        "DIContainer",
			PackageName: "test",
			Funcs:       []FuncType{f1},
		}
		g := &ContainerGenerator{Generator: Generator{
			PackageName: "test",
		}}

		if err := g.Generate(it, it.Funcs); err != nil {
			t.Fatal(err)
		}

		act := pretty(t, g.buf.Bytes())
		if !bytes.Equal(act, ex) {
			t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
		}
	})

	t.Run("Subpackage", func(t *testing.T) {
		ex := fixImports(t, []byte(`// Code generated by "dicon"; DO NOT EDIT.

	package test

	import (
		"log"

		"github.com/akito0107/dicon/sample"
		"github.com/pkg/errors"
	)

	type dicontainer struct {
		store map[string]interface{}
	}

	func NewDIContainer() DIContainer {
		return &dicontainer{
			store: map[string]interface{}{},
		}
	}

	func (d *dicontainer) SampleComponent() (sample.SampleComponent, error) {
		if i, ok := d.store["SampleComponent"]; ok {
			instance, ok := i.(sample.SampleComponent)
			if !ok {
				return nil, fmt.Errorf("invalid instance is cached %v", instance)
			}
			return instance, nil
		}
		dep0, err := d.Dependency1()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency1 failed at DICON")
		}
		dep1, err := d.Dependency2()
		if err != nil {
			return nil, errors.Wrap(err, "resolve Dependency2 failed at DICON")
		}
		instance, err := sample.NewSampleComponent(dep0, dep1)
		if err != nil {
			return nil, errors.Wrap(err, "creation SampleComponent failed at DICON")
		}
		d.store["SampleComponent"] = instance
		return instance, nil
	}`))

		p1 := ParameterType{
			DeclaredPackageName: "sample",
			src:                 createAst(t, "Dependency1"),
		}
		p2 := ParameterType{
			DeclaredPackageName: "sample",
			src:                 createAst(t, "Dependency2"),
		}
		r1 := ParameterType{
			DeclaredPackageName: "sample",
			src:                 createAst(t, "SampleComponent"),
		}
		e1 := ParameterType{
			DeclaredPackageName: "test",
			src:                 createAst(t, "error"),
		}
		f1 := FuncType{
			Name:          "SampleComponent",
			ArgumentTypes: []ParameterType{p1, p2},
			ReturnTypes:   []ParameterType{r1, e1},
			PackageName:   "sample",
		}

		it := &InterfaceType{
			Name:        "DIContainer",
			PackageName: "test",
			Funcs:       []FuncType{f1},
		}
		g := &ContainerGenerator{
			Generator: Generator{
				PackageName: "test",
			},
		}
		if err := g.Generate(it, it.Funcs); err != nil {
			t.Fatal(err)
		}

		act := fixImports(t, g.buf.Bytes())
		if !bytes.Equal(act, ex) {
			t.Errorf("Not Matched: \n%v", diff.LineDiff(string(ex), string(act)))
		}
	})
}
